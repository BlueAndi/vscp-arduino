/* The MIT License (MIT)
 *
 * Copyright (c) 2014 - 2019, Andreas Merkle
 * http://www.blue-andi.de
 * vscp@blue-andi.de
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */

/*******************************************************************************
    DESCRIPTION
*******************************************************************************/
/**
@brief  VSCP class 1 type Information events
@file   vscp_information.c
@author Andreas Merkle, http://www.blue-andi.de

@section desc Description
@see vscp_information.h

This file is automatically generated. Don't change it manually.

*******************************************************************************/

/*******************************************************************************
    INCLUDES
*******************************************************************************/
#include "vscp_information.h"
#include "../core/vscp_core.h"
#include "../core/vscp_class_l1.h"
#include "../core/vscp_type_information.h"

/*******************************************************************************
    COMPILER SWITCHES
*******************************************************************************/

/*******************************************************************************
    CONSTANTS
*******************************************************************************/

/*******************************************************************************
    MACROS
*******************************************************************************/

/*******************************************************************************
    TYPES AND STRUCTURES
*******************************************************************************/

/*******************************************************************************
    PROTOTYPES
*******************************************************************************/

/*******************************************************************************
    LOCAL VARIABLES
*******************************************************************************/

/*******************************************************************************
    GLOBAL VARIABLES
*******************************************************************************/

/*******************************************************************************
    GLOBAL FUNCTIONS
*******************************************************************************/

/**
 * This is a general event of no special type.
 *
 * @return Status
 * @retval FALSE Failed to send the event
 * @retval TRUE  Event successul sent
 *
 */
extern BOOL vscp_information_sendUndefinedEvent(void)
{
    vscp_TxMessage txMsg;

    vscp_core_prepareTxMessage(&txMsg, VSCP_CLASS_L1_INFORMATION, VSCP_TYPE_INFORMATION_UNDEFINED, VSCP_PRIORITY_3_NORMAL);

    txMsg.dataNum = 0;

    return vscp_core_sendEvent(&txMsg);
}

/**
 * A button has been pressed/released.
 *
 * @param[in] state Bits 0,1,2 If 0 the button has been released. If 1 the button is pressed. If equal
 * to 2 this is a key value (press followed by release). Bits 3-7 is repeats 0-32.
 * @param[in] zone Zone for which event applies to (0-255). 255 is all zones
 * @param[in] subZone Sub-zone for which event applies to (0-255). 255 is all sub-zones
 * @param[in] code Code for button.
 * @param[in] codePage Optional code-page.
 * @return Status
 * @retval FALSE Failed to send the event
 * @retval TRUE  Event successul sent
 *
 */
extern BOOL vscp_information_sendButtonEvent(uint8_t state, uint8_t zone, uint8_t subZone, uint16_t code, uint16_t const * const codePage)
{
    vscp_TxMessage txMsg;

    vscp_core_prepareTxMessage(&txMsg, VSCP_CLASS_L1_INFORMATION, VSCP_TYPE_INFORMATION_BUTTON, VSCP_PRIORITY_3_NORMAL);

    txMsg.dataNum = 5;
    txMsg.data[0] = state;
    txMsg.data[1] = zone;
    txMsg.data[2] = subZone;
    txMsg.data[3] = (uint8_t)((code >> 8) & 0xff);
    txMsg.data[4] = (uint8_t)((code >> 0) & 0xff);

    if (NULL != codePage)
    {
        txMsg.data[5] = (uint8_t)((*codePage >> 8) & 0xff);
        txMsg.data[6] = (uint8_t)((*codePage >> 0) & 0xff);
        txMsg.dataNum += 2;
    }


    return vscp_core_sendEvent(&txMsg);
}

/**
 * A mouse movement has occurred.
 *
 * @param[in] coordinateType If zero absolute coordinates follow. If equal to one relative coordinates
 * follow.
 * @param[in] zone Zone for which event applies to (0-255). 255 is all zones
 * @param[in] subZone Sub-zone for which event applies to (0-255). 255 is all sub-zones
 * @param[in] xCoordinate Normalized X-coordinate.
 * @param[in] yCoordinate Normalized Y-coordinate.
 * @return Status
 * @retval FALSE Failed to send the event
 * @retval TRUE  Event successul sent
 *
 */
extern BOOL vscp_information_sendMouseEvent(uint8_t coordinateType, uint8_t zone, uint8_t subZone, uint16_t xCoordinate, uint16_t yCoordinate)
{
    vscp_TxMessage txMsg;

    vscp_core_prepareTxMessage(&txMsg, VSCP_CLASS_L1_INFORMATION, VSCP_TYPE_INFORMATION_MOUSE, VSCP_PRIORITY_3_NORMAL);

    txMsg.dataNum = 7;
    txMsg.data[0] = coordinateType;
    txMsg.data[1] = zone;
    txMsg.data[2] = subZone;
    txMsg.data[3] = (uint8_t)((xCoordinate >> 8) & 0xff);
    txMsg.data[4] = (uint8_t)((xCoordinate >> 0) & 0xff);
    txMsg.data[5] = (uint8_t)((yCoordinate >> 8) & 0xff);
    txMsg.data[6] = (uint8_t)((yCoordinate >> 0) & 0xff);

    return vscp_core_sendEvent(&txMsg);
}

/**
 * A node indicates that a condition is in its on state. Heater on, lights on are two examples.
 *
 * @param[in] index Often used as an index for channels within a module.
 * @param[in] zone Zone for which event applies to (0-255). 255 is all zones.
 * @param[in] subZone Sub-zone for which event applies to (0-255). 255 is all sub-zones.
 * @return Status
 * @retval FALSE Failed to send the event
 * @retval TRUE  Event successul sent
 *
 */
extern BOOL vscp_information_sendOnEvent(uint8_t index, uint8_t zone, uint8_t subZone)
{
    vscp_TxMessage txMsg;

    vscp_core_prepareTxMessage(&txMsg, VSCP_CLASS_L1_INFORMATION, VSCP_TYPE_INFORMATION_ON, VSCP_PRIORITY_3_NORMAL);

    txMsg.dataNum = 3;
    txMsg.data[0] = index;
    txMsg.data[1] = zone;
    txMsg.data[2] = subZone;

    return vscp_core_sendEvent(&txMsg);
}

/**
 * A node indicates that a condition is in its off state. Heater off, lights off are two examples.
 *
 * @param[in] index Index.
 * @param[in] zone Zone for which event applies to (0-255). 255 is all zones.
 * @param[in] subZone Sub-zone for which event applies to (0-255). 255 is all sub-zones.
 * @return Status
 * @retval FALSE Failed to send the event
 * @retval TRUE  Event successul sent
 *
 */
extern BOOL vscp_information_sendOffEvent(uint8_t index, uint8_t zone, uint8_t subZone)
{
    vscp_TxMessage txMsg;

    vscp_core_prepareTxMessage(&txMsg, VSCP_CLASS_L1_INFORMATION, VSCP_TYPE_INFORMATION_OFF, VSCP_PRIORITY_3_NORMAL);

    txMsg.dataNum = 3;
    txMsg.data[0] = index;
    txMsg.data[1] = zone;
    txMsg.data[2] = subZone;

    return vscp_core_sendEvent(&txMsg);
}

/**
 * A node tells the world that it is alive.
 *
 * @param[in] userData User specified.
 * @param[in] zone Zone for which event applies to (0-255). 255 is all zones.
 * @param[in] subZone Sub-zone for which event applies to (0-255). 255 is all sub-zones.
 * @return Status
 * @retval FALSE Failed to send the event
 * @retval TRUE  Event successul sent
 *
 */
extern BOOL vscp_information_sendAliveEvent(uint8_t userData, uint8_t zone, uint8_t subZone)
{
    vscp_TxMessage txMsg;

    vscp_core_prepareTxMessage(&txMsg, VSCP_CLASS_L1_INFORMATION, VSCP_TYPE_INFORMATION_ALIVE, VSCP_PRIORITY_3_NORMAL);

    txMsg.dataNum = 3;
    txMsg.data[0] = userData;
    txMsg.data[1] = zone;
    txMsg.data[2] = subZone;

    return vscp_core_sendEvent(&txMsg);
}

/**
 * A node tells the world that it is terminating.
 *
 * @param[in] userData User specified.
 * @param[in] zone Zone for which event applies to (0-255). 255 is all zones.
 * @param[in] subZone Sub-zone for which event applies to (0-255). 255 is all sub-zones.
 * @return Status
 * @retval FALSE Failed to send the event
 * @retval TRUE  Event successul sent
 *
 */
extern BOOL vscp_information_sendTerminatingEvent(uint8_t userData, uint8_t zone, uint8_t subZone)
{
    vscp_TxMessage txMsg;

    vscp_core_prepareTxMessage(&txMsg, VSCP_CLASS_L1_INFORMATION, VSCP_TYPE_INFORMATION_TERMINATING, VSCP_PRIORITY_3_NORMAL);

    txMsg.dataNum = 3;
    txMsg.data[0] = userData;
    txMsg.data[1] = zone;
    txMsg.data[2] = subZone;

    return vscp_core_sendEvent(&txMsg);
}

/**
 * A node indicates that an open has occurred. This can be a door/window open, a modem line open etc.
 *
 * @param[in] userData User specified.
 * @param[in] zone Zone for which event applies to (0-255). 255 is all zones.
 * @param[in] subZone Sub-zone for which event applies to (0-255). 255 is all sub-zones.
 * @return Status
 * @retval FALSE Failed to send the event
 * @retval TRUE  Event successul sent
 *
 */
extern BOOL vscp_information_sendOpenedEvent(uint8_t userData, uint8_t zone, uint8_t subZone)
{
    vscp_TxMessage txMsg;

    vscp_core_prepareTxMessage(&txMsg, VSCP_CLASS_L1_INFORMATION, VSCP_TYPE_INFORMATION_OPENED, VSCP_PRIORITY_3_NORMAL);

    txMsg.dataNum = 3;
    txMsg.data[0] = userData;
    txMsg.data[1] = zone;
    txMsg.data[2] = subZone;

    return vscp_core_sendEvent(&txMsg);
}

/**
 * A node indicates that a close has occurred. This can be a door/window close, a modem line closure
 * etc.
 *
 * @param[in] userData User specified.
 * @param[in] zone Zone for which event applies to (0-255). 255 is all zones.
 * @param[in] subZone Sub-zone for which event applies to (0-255). 255 is all sub-zones.
 * @return Status
 * @retval FALSE Failed to send the event
 * @retval TRUE  Event successul sent
 *
 */
extern BOOL vscp_information_sendClosedEvent(uint8_t userData, uint8_t zone, uint8_t subZone)
{
    vscp_TxMessage txMsg;

    vscp_core_prepareTxMessage(&txMsg, VSCP_CLASS_L1_INFORMATION, VSCP_TYPE_INFORMATION_CLOSED, VSCP_PRIORITY_3_NORMAL);

    txMsg.dataNum = 3;
    txMsg.data[0] = userData;
    txMsg.data[1] = zone;
    txMsg.data[2] = subZone;

    return vscp_core_sendEvent(&txMsg);
}

/**
 * Heartbeats can be used to indicate that a unit is alive or to send periodic data. This can be sent
 * out at predefined intervals to indicate that the node is alive, however, it does not necessarily
 * mean the node is functioning as it should. It simply states that the node is connected to the
 * network. To check if a node is functioning, other properties such as a measurement event or
 * registry should be used. This event should be sent as a response to a “Segment Status Heartbeat”
 * (CLASS1.PROTOCOL, Type=1) in order to provide a method of finding out what is connected to the
 * network. The data bytes from byte 3 and forward can be used to send a descriptive/user friendly
 * name if desired.
 *
 *     Not mandatory but it is highly recommended that all nodes send this event on regular intervals.
 * A Level II node should not send this event but instead a Level II node heartbeat.
 *
 * @param[in] userData User specified.
 * @param[in] zone Zone for which event applies to (0-255). 255 is all zones.
 * @param[in] subZone Sub-zone for which event applies to (0-255). 255 is all sub-zones.
 * @param[in] extraData Extra data to be sent.
 * @param[in] extraDataLen Extra data length.
 * @return Status
 * @retval FALSE Failed to send the event
 * @retval TRUE  Event successul sent
 *
 */
extern BOOL vscp_information_sendNodeHeartbeatEventEx(uint8_t userData, uint8_t zone, uint8_t subZone, uint8_t const * const extraData, uint8_t extraDataLen)
{
    vscp_TxMessage  txMsg;
    uint8_t         index   = 0;
    
    if ((NULL == extraData) &&
        (0 < extraDataLen))
    {
        return FALSE;
    }
    
    if (5 < extraDataLen)
    {
        return FALSE;
    }

    vscp_core_prepareTxMessage(&txMsg, VSCP_CLASS_L1_INFORMATION, VSCP_TYPE_INFORMATION_NODE_HEARTBEAT, VSCP_PRIORITY_3_NORMAL);

    txMsg.dataNum = 3 + extraDataLen;
    txMsg.data[0] = userData;
    txMsg.data[1] = zone;
    txMsg.data[2] = subZone;

    if (0 < extraDataLen)
    {
        for(index = 0; index < extraDataLen; ++index)
        {
            txMsg.data[3 + index] = extraData[index];
        }
    }

    return vscp_core_sendEvent(&txMsg);
}

/**
 * Heartbeats can be used to indicate that a unit is alive or to send periodic data. This can be sent
 * out at predefined intervals to indicate that the node is alive, however, it does not necessarily
 * mean the node is functioning as it should. It simply states that the node is connected to the
 * network. To check if a node is functioning, other properties such as a measurement event or
 * registry should be used. This event should be sent as a response to a “Segment Status Heartbeat”
 * (CLASS1.PROTOCOL, Type=1) in order to provide a method of finding out what is connected to the
 * network. The data bytes from byte 3 and forward can be used to send a descriptive/user friendly
 * name if desired.
 *
 *     Not mandatory but it is highly recommended that all nodes send this event on regular intervals.
 * A Level II node should not send this event but instead a Level II node heartbeat.
 *
 * @param[in] userData User specified.
 * @param[in] zone Zone for which event applies to (0-255). 255 is all zones.
 * @param[in] subZone Sub-zone for which event applies to (0-255). 255 is all sub-zones.
 * @return Status
 * @retval FALSE Failed to send the event
 * @retval TRUE  Event successul sent
 *
 */
extern BOOL vscp_information_sendNodeHeartbeatEvent(uint8_t userData, uint8_t zone, uint8_t subZone)
{
   return vscp_information_sendNodeHeartbeatEventEx(userData, zone, subZone, NULL, 0);
}

/**
 * This indicates that the node has a condition that is below a configurable limit.
 *
 * @param[in] zone Zone for which event applies to (0-255). 255 is all zones.
 * @param[in] subZone Sub-zone for which event applies to (0-255). 255 is all sub-zones.
 * @return Status
 * @retval FALSE Failed to send the event
 * @retval TRUE  Event successul sent
 *
 */
extern BOOL vscp_information_sendBelowLimitEvent(uint8_t zone, uint8_t subZone)
{
    vscp_TxMessage txMsg;

    vscp_core_prepareTxMessage(&txMsg, VSCP_CLASS_L1_INFORMATION, VSCP_TYPE_INFORMATION_BELOW_LIMIT, VSCP_PRIORITY_3_NORMAL);

    txMsg.dataNum = 3;
    txMsg.data[0] = 0;
    txMsg.data[1] = zone;
    txMsg.data[2] = subZone;

    return vscp_core_sendEvent(&txMsg);
}

/**
 * This indicates that the node has a condition that is above a configurable limit.
 *
 * @param[in] zone Zone for which event applies to (0-255). 255 is all zones.
 * @param[in] subZone Sub-zone for which event applies to (0-255). 255 is all sub-zones.
 * @return Status
 * @retval FALSE Failed to send the event
 * @retval TRUE  Event successul sent
 *
 */
extern BOOL vscp_information_sendAboveLimitEvent(uint8_t zone, uint8_t subZone)
{
    vscp_TxMessage txMsg;

    vscp_core_prepareTxMessage(&txMsg, VSCP_CLASS_L1_INFORMATION, VSCP_TYPE_INFORMATION_ABOVE_LIMIT, VSCP_PRIORITY_3_NORMAL);

    txMsg.dataNum = 3;
    txMsg.data[0] = 0;
    txMsg.data[1] = zone;
    txMsg.data[2] = subZone;

    return vscp_core_sendEvent(&txMsg);
}

/**
 * This can be used for slow pulse counts. This can be an S0-pulse interface or something similar.
 *
 * @param[in] zone Zone for which event applies to (0-255). 255 is all zones.
 * @param[in] subZone Sub-zone for which event applies to (0-255). 255 is all sub-zones.
 * @return Status
 * @retval FALSE Failed to send the event
 * @retval TRUE  Event successul sent
 *
 */
extern BOOL vscp_information_sendPulseEvent(uint8_t zone, uint8_t subZone)
{
    vscp_TxMessage txMsg;

    vscp_core_prepareTxMessage(&txMsg, VSCP_CLASS_L1_INFORMATION, VSCP_TYPE_INFORMATION_PULSE, VSCP_PRIORITY_3_NORMAL);

    txMsg.dataNum = 3;
    txMsg.data[0] = 0;
    txMsg.data[1] = zone;
    txMsg.data[2] = subZone;

    return vscp_core_sendEvent(&txMsg);
}

/**
 * A node indicates that an error occurred.
 *
 * @param[in] zone Zone for which event applies to (0-255). 255 is all zones.
 * @param[in] subZone Sub-zone for which event applies to (0-255). 255 is all sub-zones.
 * @return Status
 * @retval FALSE Failed to send the event
 * @retval TRUE  Event successul sent
 *
 */
extern BOOL vscp_information_sendErrorEvent(uint8_t zone, uint8_t subZone)
{
    vscp_TxMessage txMsg;

    vscp_core_prepareTxMessage(&txMsg, VSCP_CLASS_L1_INFORMATION, VSCP_TYPE_INFORMATION_ERROR, VSCP_PRIORITY_3_NORMAL);

    txMsg.dataNum = 3;
    txMsg.data[0] = 0;
    txMsg.data[1] = zone;
    txMsg.data[2] = subZone;

    return vscp_core_sendEvent(&txMsg);
}

/**
 * A node indicates that it has resumed operation.
 *
 * @param[in] zone Zone for which event applies to (0-255). 255 is all zones.
 * @param[in] subZone Sub-zone for which event applies to (0-255). 255 is all sub-zones.
 * @return Status
 * @retval FALSE Failed to send the event
 * @retval TRUE  Event successul sent
 *
 */
extern BOOL vscp_information_sendResumedEvent(uint8_t zone, uint8_t subZone)
{
    vscp_TxMessage txMsg;

    vscp_core_prepareTxMessage(&txMsg, VSCP_CLASS_L1_INFORMATION, VSCP_TYPE_INFORMATION_RESUMED, VSCP_PRIORITY_3_NORMAL);

    txMsg.dataNum = 3;
    txMsg.data[0] = 0;
    txMsg.data[1] = zone;
    txMsg.data[2] = subZone;

    return vscp_core_sendEvent(&txMsg);
}

/**
 * A node indicates that it has paused.
 *
 * @param[in] zone Zone for which event applies to (0-255). 255 is all zones.
 * @param[in] subZone Sub-zone for which event applies to (0-255). 255 is all sub-zones.
 * @return Status
 * @retval FALSE Failed to send the event
 * @retval TRUE  Event successul sent
 *
 */
extern BOOL vscp_information_sendPausedEvent(uint8_t zone, uint8_t subZone)
{
    vscp_TxMessage txMsg;

    vscp_core_prepareTxMessage(&txMsg, VSCP_CLASS_L1_INFORMATION, VSCP_TYPE_INFORMATION_PAUSED, VSCP_PRIORITY_3_NORMAL);

    txMsg.dataNum = 3;
    txMsg.data[0] = 0;
    txMsg.data[1] = zone;
    txMsg.data[2] = subZone;

    return vscp_core_sendEvent(&txMsg);
}

/**
 * A node indicates that it entered a sleeping state.
 *
 * @param[in] zone Zone for which event applies to (0-255). 255 is all zones.
 * @param[in] subZone Sub-zone for which event applies to (0-255). 255 is all sub-zones.
 * @return Status
 * @retval FALSE Failed to send the event
 * @retval TRUE  Event successul sent
 *
 */
extern BOOL vscp_information_sendSleepingEvent(uint8_t zone, uint8_t subZone)
{
    vscp_TxMessage txMsg;

    vscp_core_prepareTxMessage(&txMsg, VSCP_CLASS_L1_INFORMATION, VSCP_TYPE_INFORMATION_SLEEPING, VSCP_PRIORITY_3_NORMAL);

    txMsg.dataNum = 3;
    txMsg.data[0] = 0;
    txMsg.data[1] = zone;
    txMsg.data[2] = subZone;

    return vscp_core_sendEvent(&txMsg);
}

/**
 * The system should enter its morning state. This can be a user pressing a button to set his/her
 * house to its morning state.
 *
 * @param[in] zone Zone for which event applies to (0-255). 255 is all zones.
 * @param[in] subZone Sub-zone for which event applies to (0-255). 255 is all sub-zones.
 * @return Status
 * @retval FALSE Failed to send the event
 * @retval TRUE  Event successul sent
 *
 */
extern BOOL vscp_information_sendGoodMorningEvent(uint8_t zone, uint8_t subZone)
{
    vscp_TxMessage txMsg;

    vscp_core_prepareTxMessage(&txMsg, VSCP_CLASS_L1_INFORMATION, VSCP_TYPE_INFORMATION_GOOD_MORNING, VSCP_PRIORITY_3_NORMAL);

    txMsg.dataNum = 3;
    txMsg.data[0] = 0;
    txMsg.data[1] = zone;
    txMsg.data[2] = subZone;

    return vscp_core_sendEvent(&txMsg);
}

/**
 * The system should enter its day state. This can be a user pressing a button to set his/her house to
 * its day state.
 *
 * @param[in] zone Zone for which event applies to (0-255). 255 is all zones.
 * @param[in] subZone Sub-zone for which event applies to (0-255). 255 is all sub-zones.
 * @return Status
 * @retval FALSE Failed to send the event
 * @retval TRUE  Event successul sent
 *
 */
extern BOOL vscp_information_sendGoodDayEvent(uint8_t zone, uint8_t subZone)
{
    vscp_TxMessage txMsg;

    vscp_core_prepareTxMessage(&txMsg, VSCP_CLASS_L1_INFORMATION, VSCP_TYPE_INFORMATION_GOOD_DAY, VSCP_PRIORITY_3_NORMAL);

    txMsg.dataNum = 3;
    txMsg.data[0] = 0;
    txMsg.data[1] = zone;
    txMsg.data[2] = subZone;

    return vscp_core_sendEvent(&txMsg);
}

/**
 * The system should enter its afternoon state. This can be a user pressing a button to set his/her
 * house to its afternoon state.
 *
 * @param[in] zone Zone for which event applies to (0-255). 255 is all zones.
 * @param[in] subZone Sub-zone for which event applies to (0-255). 255 is all sub-zones.
 * @return Status
 * @retval FALSE Failed to send the event
 * @retval TRUE  Event successul sent
 *
 */
extern BOOL vscp_information_sendGoodAfternoonEvent(uint8_t zone, uint8_t subZone)
{
    vscp_TxMessage txMsg;

    vscp_core_prepareTxMessage(&txMsg, VSCP_CLASS_L1_INFORMATION, VSCP_TYPE_INFORMATION_GOOD_AFTERNOON, VSCP_PRIORITY_3_NORMAL);

    txMsg.dataNum = 3;
    txMsg.data[0] = 0;
    txMsg.data[1] = zone;
    txMsg.data[2] = subZone;

    return vscp_core_sendEvent(&txMsg);
}

/**
 * The system should enter its evening state. This can be a user pressing a button to set his/her
 * house to its evening state.
 *
 * @param[in] zone Zone for which event applies to (0-255). 255 is all zones.
 * @param[in] subZone Sub-zone for which event applies to (0-255). 255 is all sub-zones.
 * @return Status
 * @retval FALSE Failed to send the event
 * @retval TRUE  Event successul sent
 *
 */
extern BOOL vscp_information_sendGoodEveningEvent(uint8_t zone, uint8_t subZone)
{
    vscp_TxMessage txMsg;

    vscp_core_prepareTxMessage(&txMsg, VSCP_CLASS_L1_INFORMATION, VSCP_TYPE_INFORMATION_GOOD_EVENING, VSCP_PRIORITY_3_NORMAL);

    txMsg.dataNum = 3;
    txMsg.data[0] = 0;
    txMsg.data[1] = zone;
    txMsg.data[2] = subZone;

    return vscp_core_sendEvent(&txMsg);
}

/**
 * The system should enter its night state. This can be a user pressing a button to set his/her house
 * to its night state.
 *
 * @param[in] zone Zone for which event applies to (0-255). 255 is all zones.
 * @param[in] subZone Sub-zone for which event applies to (0-255). 255 is all sub-zones.
 * @return Status
 * @retval FALSE Failed to send the event
 * @retval TRUE  Event successul sent
 *
 */
extern BOOL vscp_information_sendGoodNightEvent(uint8_t zone, uint8_t subZone)
{
    vscp_TxMessage txMsg;

    vscp_core_prepareTxMessage(&txMsg, VSCP_CLASS_L1_INFORMATION, VSCP_TYPE_INFORMATION_GOOD_NIGHT, VSCP_PRIORITY_3_NORMAL);

    txMsg.dataNum = 3;
    txMsg.data[0] = 0;
    txMsg.data[1] = zone;
    txMsg.data[2] = subZone;

    return vscp_core_sendEvent(&txMsg);
}

/**
 * The system should be on a temporary alert. This can be a user locking the door to go out to the
 * waste bin or similar situation. An alarm system should not be activated in this situation.
 *
 * @param[in] zone Zone for which event applies to (0-255). 255 is all zones.
 * @param[in] subZone Sub-zone for which event applies to (0-255). 255 is all sub-zones.
 * @return Status
 * @retval FALSE Failed to send the event
 * @retval TRUE  Event successul sent
 *
 */
extern BOOL vscp_information_sendSeeYouSoonEvent(uint8_t zone, uint8_t subZone)
{
    vscp_TxMessage txMsg;

    vscp_core_prepareTxMessage(&txMsg, VSCP_CLASS_L1_INFORMATION, VSCP_TYPE_INFORMATION_SEE_YOU_SOON, VSCP_PRIORITY_3_NORMAL);

    txMsg.dataNum = 3;
    txMsg.data[0] = 0;
    txMsg.data[1] = zone;
    txMsg.data[2] = subZone;

    return vscp_core_sendEvent(&txMsg);
}

/**
 * The system should be on a goodbye alert. This can be a user locking the door to go out for a days
 * work or similar situation. All alarm systems should be activated in this situation.
 *
 * @param[in] zone Zone for which event applies to (0-255). 255 is all zones.
 * @param[in] subZone Sub-zone for which event applies to (0-255). 255 is all sub-zones.
 * @return Status
 * @retval FALSE Failed to send the event
 * @retval TRUE  Event successul sent
 *
 */
extern BOOL vscp_information_sendGoodbyeEvent(uint8_t zone, uint8_t subZone)
{
    vscp_TxMessage txMsg;

    vscp_core_prepareTxMessage(&txMsg, VSCP_CLASS_L1_INFORMATION, VSCP_TYPE_INFORMATION_GOODBYE, VSCP_PRIORITY_3_NORMAL);

    txMsg.dataNum = 3;
    txMsg.data[0] = 0;
    txMsg.data[1] = zone;
    txMsg.data[2] = subZone;

    return vscp_core_sendEvent(&txMsg);
}

/**
 * A node indicates that a stop event occurred. This can for example be a motor stopping.
 *
 * @param[in] reserved Reserved for any kind of information
 * @param[in] zone Zone for which event applies to (0-255). 255 is all zones.
 * @param[in] subZone Sub-zone for which event applies to (0-255). 255 is all sub-zones.
 * @return Status
 * @retval FALSE Failed to send the event
 * @retval TRUE  Event successul sent
 *
 */
extern BOOL vscp_information_sendStopEvent(uint8_t reserved, uint8_t zone, uint8_t subZone)
{
    vscp_TxMessage txMsg;

    vscp_core_prepareTxMessage(&txMsg, VSCP_CLASS_L1_INFORMATION, VSCP_TYPE_INFORMATION_STOP, VSCP_PRIORITY_3_NORMAL);

    txMsg.dataNum = 3;
    txMsg.data[0] = reserved;
    txMsg.data[1] = zone;
    txMsg.data[2] = subZone;

    return vscp_core_sendEvent(&txMsg);
}

/**
 * A node indicates that a start event occurred. This can be a motor starting.
 *
 * @param[in] zone Zone for which event applies to (0-255). 255 is all zones.
 * @param[in] subZone Sub-zone for which event applies to (0-255). 255 is all sub-zones.
 * @return Status
 * @retval FALSE Failed to send the event
 * @retval TRUE  Event successul sent
 *
 */
extern BOOL vscp_information_sendStartEvent(uint8_t zone, uint8_t subZone)
{
    vscp_TxMessage txMsg;

    vscp_core_prepareTxMessage(&txMsg, VSCP_CLASS_L1_INFORMATION, VSCP_TYPE_INFORMATION_START, VSCP_PRIORITY_3_NORMAL);

    txMsg.dataNum = 3;
    txMsg.data[0] = 0;
    txMsg.data[1] = zone;
    txMsg.data[2] = subZone;

    return vscp_core_sendEvent(&txMsg);
}

/**
 * A node indicates that a reset occurred. This can be a node doing a warm start.
 *
 * @param[in] zone Zone for which event applies to (0-255). 255 is all zones.
 * @param[in] subZone Sub-zone for which event applies to (0-255). 255 is all sub-zones.
 * @return Status
 * @retval FALSE Failed to send the event
 * @retval TRUE  Event successul sent
 *
 */
extern BOOL vscp_information_sendResetCompletedEvent(uint8_t zone, uint8_t subZone)
{
    vscp_TxMessage txMsg;

    vscp_core_prepareTxMessage(&txMsg, VSCP_CLASS_L1_INFORMATION, VSCP_TYPE_INFORMATION_RESET_COMPLETED, VSCP_PRIORITY_3_NORMAL);

    txMsg.dataNum = 3;
    txMsg.data[0] = 0;
    txMsg.data[1] = zone;
    txMsg.data[2] = subZone;

    return vscp_core_sendEvent(&txMsg);
}

/**
 * A node indicates that a reset occurred. This can also be a node doing a warm start.
 *
 * @param[in] zone Zone for which event applies to (0-255). 255 is all zones.
 * @param[in] subZone Sub-zone for which event applies to (0-255). 255 is all sub-zones.
 * @return Status
 * @retval FALSE Failed to send the event
 * @retval TRUE  Event successul sent
 *
 */
extern BOOL vscp_information_sendInterruptedEvent(uint8_t zone, uint8_t subZone)
{
    vscp_TxMessage txMsg;

    vscp_core_prepareTxMessage(&txMsg, VSCP_CLASS_L1_INFORMATION, VSCP_TYPE_INFORMATION_INTERRUPTED, VSCP_PRIORITY_3_NORMAL);

    txMsg.dataNum = 3;
    txMsg.data[0] = 0;
    txMsg.data[1] = zone;
    txMsg.data[2] = subZone;

    return vscp_core_sendEvent(&txMsg);
}

/**
 * A node indicates that a sleep event occurred. This can be a node going to its inactive state.
 *
 * @param[in] zone Zone for which event applies to (0-255). 255 is all zones.
 * @param[in] subZone Sub-zone for which event applies to (0-255). 255 is all sub-zones.
 * @return Status
 * @retval FALSE Failed to send the event
 * @retval TRUE  Event successul sent
 *
 */
extern BOOL vscp_information_sendPreparingToSleepEvent(uint8_t zone, uint8_t subZone)
{
    vscp_TxMessage txMsg;

    vscp_core_prepareTxMessage(&txMsg, VSCP_CLASS_L1_INFORMATION, VSCP_TYPE_INFORMATION_PREPARING_TO_SLEEP, VSCP_PRIORITY_3_NORMAL);

    txMsg.dataNum = 3;
    txMsg.data[0] = 0;
    txMsg.data[1] = zone;
    txMsg.data[2] = subZone;

    return vscp_core_sendEvent(&txMsg);
}

/**
 * A node indicates that a wakeup event occurred. This can be a node going to it awake state.
 *
 * @param[in] zone Zone for which event applies to (0-255). 255 is all zones.
 * @param[in] subZone Sub-zone for which event applies to (0-255). 255 is all sub-zones.
 * @return Status
 * @retval FALSE Failed to send the event
 * @retval TRUE  Event successul sent
 *
 */
extern BOOL vscp_information_sendWokenUpEvent(uint8_t zone, uint8_t subZone)
{
    vscp_TxMessage txMsg;

    vscp_core_prepareTxMessage(&txMsg, VSCP_CLASS_L1_INFORMATION, VSCP_TYPE_INFORMATION_WOKEN_UP, VSCP_PRIORITY_3_NORMAL);

    txMsg.dataNum = 3;
    txMsg.data[0] = 0;
    txMsg.data[1] = zone;
    txMsg.data[2] = subZone;

    return vscp_core_sendEvent(&txMsg);
}

/**
 * A node indicates that the system should enter its dusk state.
 *
 * @param[in] zone Zone for which event applies to (0-255). 255 is all zones.
 * @param[in] subZone Sub-zone for which event applies to (0-255). 255 is all sub-zones.
 * @return Status
 * @retval FALSE Failed to send the event
 * @retval TRUE  Event successul sent
 *
 */
extern BOOL vscp_information_sendDuskEvent(uint8_t zone, uint8_t subZone)
{
    vscp_TxMessage txMsg;

    vscp_core_prepareTxMessage(&txMsg, VSCP_CLASS_L1_INFORMATION, VSCP_TYPE_INFORMATION_DUSK, VSCP_PRIORITY_3_NORMAL);

    txMsg.dataNum = 3;
    txMsg.data[0] = 0;
    txMsg.data[1] = zone;
    txMsg.data[2] = subZone;

    return vscp_core_sendEvent(&txMsg);
}

/**
 * A node indicates that the system should enter its dawn state.
 *
 * @param[in] zone Zone for which event applies to (0-255). 255 is all zones.
 * @param[in] subZone Sub-zone for which event applies to (0-255). 255 is all sub-zones.
 * @return Status
 * @retval FALSE Failed to send the event
 * @retval TRUE  Event successul sent
 *
 */
extern BOOL vscp_information_sendDawnEvent(uint8_t zone, uint8_t subZone)
{
    vscp_TxMessage txMsg;

    vscp_core_prepareTxMessage(&txMsg, VSCP_CLASS_L1_INFORMATION, VSCP_TYPE_INFORMATION_DAWN, VSCP_PRIORITY_3_NORMAL);

    txMsg.dataNum = 3;
    txMsg.data[0] = 0;
    txMsg.data[1] = zone;
    txMsg.data[2] = subZone;

    return vscp_core_sendEvent(&txMsg);
}

/**
 * A node indicates that its active.
 *
 * @param[in] zone Zone for which event applies to (0-255). 255 is all zones.
 * @param[in] subZone Sub-zone for which event applies to (0-255). 255 is all sub-zones.
 * @return Status
 * @retval FALSE Failed to send the event
 * @retval TRUE  Event successul sent
 *
 */
extern BOOL vscp_information_sendActiveEvent(uint8_t zone, uint8_t subZone)
{
    vscp_TxMessage txMsg;

    vscp_core_prepareTxMessage(&txMsg, VSCP_CLASS_L1_INFORMATION, VSCP_TYPE_INFORMATION_ACTIVE, VSCP_PRIORITY_3_NORMAL);

    txMsg.dataNum = 3;
    txMsg.data[0] = 0;
    txMsg.data[1] = zone;
    txMsg.data[2] = subZone;

    return vscp_core_sendEvent(&txMsg);
}

/**
 * A node indicates that its inactive.
 *
 * @param[in] zone Zone for which event applies to (0-255). 255 is all zones.
 * @param[in] subZone Sub-zone for which event applies to (0-255). 255 is all sub-zones.
 * @return Status
 * @retval FALSE Failed to send the event
 * @retval TRUE  Event successul sent
 *
 */
extern BOOL vscp_information_sendInactiveEvent(uint8_t zone, uint8_t subZone)
{
    vscp_TxMessage txMsg;

    vscp_core_prepareTxMessage(&txMsg, VSCP_CLASS_L1_INFORMATION, VSCP_TYPE_INFORMATION_INACTIVE, VSCP_PRIORITY_3_NORMAL);

    txMsg.dataNum = 3;
    txMsg.data[0] = 0;
    txMsg.data[1] = zone;
    txMsg.data[2] = subZone;

    return vscp_core_sendEvent(&txMsg);
}

/**
 * A node indicates that its busy.
 *
 * @param[in] zone Zone for which event applies to (0-255). 255 is all zones.
 * @param[in] subZone Sub-zone for which event applies to (0-255). 255 is all sub-zones.
 * @return Status
 * @retval FALSE Failed to send the event
 * @retval TRUE  Event successul sent
 *
 */
extern BOOL vscp_information_sendBusyEvent(uint8_t zone, uint8_t subZone)
{
    vscp_TxMessage txMsg;

    vscp_core_prepareTxMessage(&txMsg, VSCP_CLASS_L1_INFORMATION, VSCP_TYPE_INFORMATION_BUSY, VSCP_PRIORITY_3_NORMAL);

    txMsg.dataNum = 3;
    txMsg.data[0] = 0;
    txMsg.data[1] = zone;
    txMsg.data[2] = subZone;

    return vscp_core_sendEvent(&txMsg);
}

/**
 * A node indicates that its idle.
 *
 * @param[in] zone Zone for which event applies to (0-255). 255 is all zones.
 * @param[in] subZone Sub-zone for which event applies to (0-255). 255 is all sub-zones.
 * @return Status
 * @retval FALSE Failed to send the event
 * @retval TRUE  Event successul sent
 *
 */
extern BOOL vscp_information_sendIdleEvent(uint8_t zone, uint8_t subZone)
{
    vscp_TxMessage txMsg;

    vscp_core_prepareTxMessage(&txMsg, VSCP_CLASS_L1_INFORMATION, VSCP_TYPE_INFORMATION_IDLE, VSCP_PRIORITY_3_NORMAL);

    txMsg.dataNum = 3;
    txMsg.data[0] = 0;
    txMsg.data[1] = zone;
    txMsg.data[2] = subZone;

    return vscp_core_sendEvent(&txMsg);
}

/**
 * A steam of information from a node can be reported with this event. This can be a serial RS-232
 * channel or some other sequential stream.
 *
 * @param[in] sequenceNumber Sequence number which is increased by one for every new event with stream
 * data. The sequence number is increased for every frame sent going from 0 - 255 and back to 0 and so
 * on if needed. A new stream starts with a sequence number of 0.
 * @param[in] data Stream data.
 * @param[in] dataSize Size in bytes (1-7)
 * @return Status
 * @retval FALSE Failed to send the event
 * @retval TRUE  Event successul sent
 *
 */
extern BOOL vscp_information_sendStreamDataEvent(uint8_t sequenceNumber, uint8_t const * const data, uint8_t dataSize)
{
    uint8_t byteIndex = 0;
    vscp_TxMessage txMsg;

    vscp_core_prepareTxMessage(&txMsg, VSCP_CLASS_L1_INFORMATION, VSCP_TYPE_INFORMATION_STREAM_DATA, VSCP_PRIORITY_3_NORMAL);

    txMsg.dataNum = 1;
    txMsg.data[0] = sequenceNumber;

    for(byteIndex = 0; byteIndex < dataSize; ++byteIndex)
    {
        txMsg.data[1 + byteIndex] = data[byteIndex];
        ++txMsg.dataNum;

        if (VSCP_L1_DATA_SIZE <= txMsg.dataNum)
        {
            break;
        }
    }

    return vscp_core_sendEvent(&txMsg);
}

/**
 * This event is used for cards, RFID's, iButtons, GSM phones and other identification devices. The
 * event is generated when the token device is attached/detached to/from the system. Level II has a
 * counterpart to this event that can take more data. CLASS2.INFORMATION Type=1
 *
 *     Depending on the Token device type a number of this event are sent on the segment with frame
 * index increase for each event. The total expected number can be deduced from the type.
 *
 * @param[in] code Bit 0,1 - Event code. Bit 2-7 - Token device type code.
 * @param[in] zone Zone.
 * @param[in] subZone Sub-zone.
 * @param[in] index Frame index (Increase by one for every frame sent out for one token activity.
 * Start with zero ).
 * @param[in] tokenData Token data.
 * @param[in] tokenDataSize Size in bytes (1-4)
 * @return Status
 * @retval FALSE Failed to send the event
 * @retval TRUE  Event successul sent
 *
 */
extern BOOL vscp_information_sendTokenActivityEvent(uint8_t code, uint8_t zone, uint8_t subZone, uint8_t index, uint8_t const * const tokenData, uint8_t tokenDataSize)
{
    uint8_t byteIndex = 0;
    vscp_TxMessage txMsg;

    vscp_core_prepareTxMessage(&txMsg, VSCP_CLASS_L1_INFORMATION, VSCP_TYPE_INFORMATION_TOKEN_ACTIVITY, VSCP_PRIORITY_3_NORMAL);

    txMsg.dataNum = 4;
    txMsg.data[0] = code;
    txMsg.data[1] = zone;
    txMsg.data[2] = subZone;
    txMsg.data[3] = index;

    for(byteIndex = 0; byteIndex < tokenDataSize; ++byteIndex)
    {
        txMsg.data[4 + byteIndex] = tokenData[byteIndex];
        ++txMsg.dataNum;

        if (VSCP_L1_DATA_SIZE <= txMsg.dataNum)
        {
            break;
        }
    }

    return vscp_core_sendEvent(&txMsg);
}

/**
 * A steam of information from a node can be reported with this event. This can be a serial RS-232
 * channel or some other sequential stream.
 *
 * @param[in] zone Zone.
 * @param[in] subZone Sub-zone.
 * @param[in] sequenceNumber Sequence number which is increased by one for every new event with stream
 * data. The sequence number is increased for every frame sent going from 0 - 255 and back to 0 and so
 * on if needed. A new stream starts with a sequence number of 0.
 * @param[in] data Stream data.
 * @param[in] dataSize Size in bytes (1-5)
 * @return Status
 * @retval FALSE Failed to send the event
 * @retval TRUE  Event successul sent
 *
 */
extern BOOL vscp_information_sendStreamDataWithZoneEvent(uint8_t zone, uint8_t subZone, uint8_t sequenceNumber, uint8_t const * const data, uint8_t dataSize)
{
    uint8_t byteIndex = 0;
    vscp_TxMessage txMsg;

    vscp_core_prepareTxMessage(&txMsg, VSCP_CLASS_L1_INFORMATION, VSCP_TYPE_INFORMATION_STREAM_DATA_WITH_ZONE, VSCP_PRIORITY_3_NORMAL);

    txMsg.dataNum = 3;
    txMsg.data[0] = zone;
    txMsg.data[1] = subZone;
    txMsg.data[2] = sequenceNumber;

    for(byteIndex = 0; byteIndex < dataSize; ++byteIndex)
    {
        txMsg.data[3 + byteIndex] = data[byteIndex];
        ++txMsg.dataNum;

        if (VSCP_L1_DATA_SIZE <= txMsg.dataNum)
        {
            break;
        }
    }

    return vscp_core_sendEvent(&txMsg);
}

/**
 * This event can be used as a general confirm event for zoned and stream data.
 *
 * @param[in] zone Zone.
 * @param[in] subZone Sub-zone.
 * @param[in] sequenceNumber Sequence number byte.
 * @param[in] class Class.
 * @param[in] type Type.
 * @return Status
 * @retval FALSE Failed to send the event
 * @retval TRUE  Event successul sent
 *
 */
extern BOOL vscp_information_sendConfirmEvent(uint8_t zone, uint8_t subZone, uint8_t sequenceNumber, uint16_t class, uint16_t type)
{
    vscp_TxMessage txMsg;

    vscp_core_prepareTxMessage(&txMsg, VSCP_CLASS_L1_INFORMATION, VSCP_TYPE_INFORMATION_CONFIRM, VSCP_PRIORITY_3_NORMAL);

    txMsg.dataNum = 7;
    txMsg.data[0] = zone;
    txMsg.data[1] = subZone;
    txMsg.data[2] = sequenceNumber;
    txMsg.data[3] = (uint8_t)((class >> 8) & 0xff);
    txMsg.data[4] = (uint8_t)((class >> 0) & 0xff);
    txMsg.data[5] = (uint8_t)((type >> 8) & 0xff);
    txMsg.data[6] = (uint8_t)((type >> 0) & 0xff);

    return vscp_core_sendEvent(&txMsg);
}

/**
 * Response/confirmation from ex. a dimmer control after a dimmer command or some other unit that
 * change a level.
 *
 * @param[in] levelType Relative or absolute level.
 * @param[in] zone Zone for which event applies to (0-255). 255 is all zones.
 * @param[in] subZone Sub-zone for which event applies to (0-255). 255 is all sub-zones.
 * @return Status
 * @retval FALSE Failed to send the event
 * @retval TRUE  Event successul sent
 *
 */
extern BOOL vscp_information_sendLevelChangedEvent(uint8_t levelType, uint8_t zone, uint8_t subZone)
{
    vscp_TxMessage txMsg;

    vscp_core_prepareTxMessage(&txMsg, VSCP_CLASS_L1_INFORMATION, VSCP_TYPE_INFORMATION_LEVEL_CHANGED, VSCP_PRIORITY_3_NORMAL);

    txMsg.dataNum = 3;
    txMsg.data[0] = levelType;
    txMsg.data[1] = zone;
    txMsg.data[2] = subZone;

    return vscp_core_sendEvent(&txMsg);
}

/**
 * A node indicates that a warning condition occurred.
 *
 * @param[in] levelType Relative or absolute level.
 * @param[in] zone Zone for which event applies to (0-255). 255 is all zones.
 * @param[in] subZone Sub-zone for which event applies to (0-255). 255 is all sub-zones.
 * @return Status
 * @retval FALSE Failed to send the event
 * @retval TRUE  Event successul sent
 *
 */
extern BOOL vscp_information_sendWarningEvent(uint8_t levelType, uint8_t zone, uint8_t subZone)
{
    vscp_TxMessage txMsg;

    vscp_core_prepareTxMessage(&txMsg, VSCP_CLASS_L1_INFORMATION, VSCP_TYPE_INFORMATION_WARNING, VSCP_PRIORITY_3_NORMAL);

    txMsg.dataNum = 3;
    txMsg.data[0] = levelType;
    txMsg.data[1] = zone;
    txMsg.data[2] = subZone;

    return vscp_core_sendEvent(&txMsg);
}

/**
 * A node indicates that a state change has occurred. Th numerical ID for the current state and the
 * state that is about to become active is supplied.
 *
 * @param[in] userData User specified.
 * @param[in] zone Zone for which event applies to (0-255). 255 is all zones.
 * @param[in] subZone Sub-zone for which event applies to (0-255). 255 is all sub-zones.
 * @param[in] previousState State changed from.
 * @param[in] currentState New State.
 * @return Status
 * @retval FALSE Failed to send the event
 * @retval TRUE  Event successul sent
 *
 */
extern BOOL vscp_information_sendStateEvent(uint8_t userData, uint8_t zone, uint8_t subZone, uint8_t previousState, uint8_t currentState)
{
    vscp_TxMessage txMsg;

    vscp_core_prepareTxMessage(&txMsg, VSCP_CLASS_L1_INFORMATION, VSCP_TYPE_INFORMATION_STATE, VSCP_PRIORITY_3_NORMAL);

    txMsg.dataNum = 5;
    txMsg.data[0] = userData;
    txMsg.data[1] = zone;
    txMsg.data[2] = subZone;
    txMsg.data[3] = previousState;
    txMsg.data[4] = currentState;

    return vscp_core_sendEvent(&txMsg);
}

/**
 * A node optionally indicates that an action has been triggered by this event.
 *
 * @param[in] actionId Action ID.
 * @param[in] zone Zone for which event applies to (0-255). 255 is all zones.
 * @param[in] subZone Sub-zone for which event applies to (0-255). 255 is all sub-zones.
 * @return Status
 * @retval FALSE Failed to send the event
 * @retval TRUE  Event successul sent
 *
 */
extern BOOL vscp_information_sendActionTriggerEvent(uint8_t actionId, uint8_t zone, uint8_t subZone)
{
    vscp_TxMessage txMsg;

    vscp_core_prepareTxMessage(&txMsg, VSCP_CLASS_L1_INFORMATION, VSCP_TYPE_INFORMATION_ACTION_TRIGGER, VSCP_PRIORITY_3_NORMAL);

    txMsg.dataNum = 3;
    txMsg.data[0] = actionId;
    txMsg.data[1] = zone;
    txMsg.data[2] = subZone;

    return vscp_core_sendEvent(&txMsg);
}

/**
 * A node indicates that sunrise is detected/calculated.
 *
 * @param[in] userData User specified.
 * @param[in] zone Zone for which event applies to (0-255). 255 is all zones.
 * @param[in] subZone Sub-zone for which event applies to (0-255). 255 is all sub-zones.
 * @return Status
 * @retval FALSE Failed to send the event
 * @retval TRUE  Event successul sent
 *
 */
extern BOOL vscp_information_sendSunriseEvent(uint8_t userData, uint8_t zone, uint8_t subZone)
{
    vscp_TxMessage txMsg;

    vscp_core_prepareTxMessage(&txMsg, VSCP_CLASS_L1_INFORMATION, VSCP_TYPE_INFORMATION_SUNRISE, VSCP_PRIORITY_3_NORMAL);

    txMsg.dataNum = 3;
    txMsg.data[0] = userData;
    txMsg.data[1] = zone;
    txMsg.data[2] = subZone;

    return vscp_core_sendEvent(&txMsg);
}

/**
 * A node indicates that sunset is detected/calculated.
 *
 * @param[in] userData User specified.
 * @param[in] zone Zone for which event applies to (0-255). 255 is all zones.
 * @param[in] subZone Sub-zone for which event applies to (0-255). 255 is all sub-zones.
 * @return Status
 * @retval FALSE Failed to send the event
 * @retval TRUE  Event successul sent
 *
 */
extern BOOL vscp_information_sendSunsetEvent(uint8_t userData, uint8_t zone, uint8_t subZone)
{
    vscp_TxMessage txMsg;

    vscp_core_prepareTxMessage(&txMsg, VSCP_CLASS_L1_INFORMATION, VSCP_TYPE_INFORMATION_SUNSET, VSCP_PRIORITY_3_NORMAL);

    txMsg.dataNum = 3;
    txMsg.data[0] = userData;
    txMsg.data[1] = zone;
    txMsg.data[2] = subZone;

    return vscp_core_sendEvent(&txMsg);
}

/**
 * This event is used to mark the start of a multi-frame data transfer. This can typically be a GPS
 * received which sends a train of events from one GPS record. The index byte can be used to
 * distinguish record between each other.
 *
 * @param[in] index Index for record.
 * @param[in] zone Zone for which event applies to (0-255). 255 is all zones.
 * @param[in] subZone Sub-zone for which event applies to (0-255). 255 is all sub-zones.
 * @param[in] num Number of frames to follow or zero for not used.
 * @return Status
 * @retval FALSE Failed to send the event
 * @retval TRUE  Event successul sent
 *
 */
extern BOOL vscp_information_sendStartOfRecordEvent(uint8_t index, uint8_t zone, uint8_t subZone, uint8_t num)
{
    vscp_TxMessage txMsg;

    vscp_core_prepareTxMessage(&txMsg, VSCP_CLASS_L1_INFORMATION, VSCP_TYPE_INFORMATION_START_OF_RECORD, VSCP_PRIORITY_3_NORMAL);

    txMsg.dataNum = 4;
    txMsg.data[0] = index;
    txMsg.data[1] = zone;
    txMsg.data[2] = subZone;
    txMsg.data[3] = num;

    return vscp_core_sendEvent(&txMsg);
}

/**
 * This event is used to mark the end of a multi-frame data transfer. The index byte can be used to
 * distinguish record between each other.
 *
 * @param[in] index Index for record.
 * @param[in] zone Zone for which event applies to (0-255). 255 is all zones.
 * @param[in] subZone Sub-zone for which event applies to (0-255). 255 is all sub-zones.
 * @return Status
 * @retval FALSE Failed to send the event
 * @retval TRUE  Event successul sent
 *
 */
extern BOOL vscp_information_sendEndOfRecordEvent(uint8_t index, uint8_t zone, uint8_t subZone)
{
    vscp_TxMessage txMsg;

    vscp_core_prepareTxMessage(&txMsg, VSCP_CLASS_L1_INFORMATION, VSCP_TYPE_INFORMATION_END_OF_RECORD, VSCP_PRIORITY_3_NORMAL);

    txMsg.dataNum = 3;
    txMsg.data[0] = index;
    txMsg.data[1] = zone;
    txMsg.data[2] = subZone;

    return vscp_core_sendEvent(&txMsg);
}

/**
 * This event is used to tell the system that a pre-set configuration is active. Usually a response
 * from a node after a CLASS1.CONTROL, Type=28 has been received by a node.
 *
 * @param[in] zone Zone for which event applies to (0-255). 255 is all zones.
 * @param[in] subZone Sub-zone for which event applies to (0-255). 255 is all sub-zones.
 * @param[in] code Code for pre-set that has been set.
 * @return Status
 * @retval FALSE Failed to send the event
 * @retval TRUE  Event successul sent
 *
 */
extern BOOL vscp_information_sendPresetActiveEvent(uint8_t zone, uint8_t subZone, uint8_t code)
{
    vscp_TxMessage txMsg;

    vscp_core_prepareTxMessage(&txMsg, VSCP_CLASS_L1_INFORMATION, VSCP_TYPE_INFORMATION_PRESET_ACTIVE, VSCP_PRIORITY_3_NORMAL);

    txMsg.dataNum = 4;
    txMsg.data[0] = 0;
    txMsg.data[1] = zone;
    txMsg.data[2] = subZone;
    txMsg.data[3] = code;

    return vscp_core_sendEvent(&txMsg);
}

/**
 * This event is used to tell the system that a detection of some kind has occurred.
 *
 * @param[in] index Index.
 * @param[in] zone Zone for which event applies to (0-255). 255 is all zones.
 * @param[in] subZone Sub-zone for which event applies to (0-255). 255 is all sub-zones.
 * @return Status
 * @retval FALSE Failed to send the event
 * @retval TRUE  Event successul sent
 *
 */
extern BOOL vscp_information_sendDetectEvent(uint8_t index, uint8_t zone, uint8_t subZone)
{
    vscp_TxMessage txMsg;

    vscp_core_prepareTxMessage(&txMsg, VSCP_CLASS_L1_INFORMATION, VSCP_TYPE_INFORMATION_DETECT, VSCP_PRIORITY_3_NORMAL);

    txMsg.dataNum = 3;
    txMsg.data[0] = index;
    txMsg.data[1] = zone;
    txMsg.data[2] = subZone;

    return vscp_core_sendEvent(&txMsg);
}

/**
 * This event is used to tell the system that an overflow of some kind has occurred.
 *
 * @param[in] index Index.
 * @param[in] zone Zone for which event applies to (0-255). 255 is all zones.
 * @param[in] subZone Sub-zone for which event applies to (0-255). 255 is all sub-zones.
 * @return Status
 * @retval FALSE Failed to send the event
 * @retval TRUE  Event successul sent
 *
 */
extern BOOL vscp_information_sendOverflowEvent(uint8_t index, uint8_t zone, uint8_t subZone)
{
    vscp_TxMessage txMsg;

    vscp_core_prepareTxMessage(&txMsg, VSCP_CLASS_L1_INFORMATION, VSCP_TYPE_INFORMATION_OVERFLOW, VSCP_PRIORITY_3_NORMAL);

    txMsg.dataNum = 3;
    txMsg.data[0] = index;
    txMsg.data[1] = zone;
    txMsg.data[2] = subZone;

    return vscp_core_sendEvent(&txMsg);
}

/**
 * This is meant to be used as a confirmation event for CLASS1.CONTROL, Type=33 events.
 *
 * @param[in] index Index.
 * @param[in] zone Zone for which event applies to (0-255). 255 is all zones.
 * @param[in] subZone Sub-zone for which event applies to (0-255). 255 is all sub-zones.
 * @param[in] level Level as signed Integer. The range can be adjusted by the user by sending the
 * needed number of bytes 1-5.
 * @param[in] levelSize Size in bytes (1-5)
 * @return Status
 * @retval FALSE Failed to send the event
 * @retval TRUE  Event successul sent
 *
 */
extern BOOL vscp_information_sendBigLevelChangedEvent(uint8_t index, uint8_t zone, uint8_t subZone, int8_t const * const level, uint8_t levelSize)
{
    uint8_t byteIndex = 0;
    vscp_TxMessage txMsg;

    vscp_core_prepareTxMessage(&txMsg, VSCP_CLASS_L1_INFORMATION, VSCP_TYPE_INFORMATION_BIG_LEVEL_CHANGED, VSCP_PRIORITY_3_NORMAL);

    txMsg.dataNum = 3;
    txMsg.data[0] = index;
    txMsg.data[1] = zone;
    txMsg.data[2] = subZone;

    for(byteIndex = 0; byteIndex < levelSize; ++byteIndex)
    {
        txMsg.data[3 + byteIndex] = level[byteIndex];
        ++txMsg.dataNum;

        if (VSCP_L1_DATA_SIZE <= txMsg.dataNum)
        {
            break;
        }
    }

    return vscp_core_sendEvent(&txMsg);
}

/**
 * Civil twilight is the period when the Sun is below the horizon but its center is less than 6
 * degrees below. The “Civil Twilight Starts” time is the dawn or civil dawn, with the center of the
 * Sun at exactly 6 degrees below the horizon. Equally, the “Civil Twilight Ends” time is dusk or
 * civil dusk, when the Sun is 6 degrees below the horizon in the evening.
 *
 *     During civil twilight, the sky is still illuminated, and with clear weather it is brightest in
 * the direction of the Sun. The Moon and the brightest stars and planets may be visible. It is
 * usually bright enough for outdoor activities without additional lighting.
 *
 *     Near the equator, where the Sun sets and rises in an almost vertical direction, the civil
 * twilight period can last only 21 minutes, a very fast nightfall compared to the much longer periods
 * at southern and northern latitudes. In regions north of 60°24' N or south of 60°24' S, there will
 * be at least one night when it does not get darker than this.
 *
 *     Technically, the start and end times are when the true geocentric position of the Sun is 96
 * degrees from the zenith position.
 *
 *     A node indicates that sunrise twilight time is detected/calculated.
 *
 * @param[in] userData User specified.
 * @param[in] zone Zone for which event applies to (0-255). 255 is all zones.
 * @param[in] subZone Sub-zone for which event applies to (0-255). 255 is all sub-zones.
 * @return Status
 * @retval FALSE Failed to send the event
 * @retval TRUE  Event successul sent
 *
 */
extern BOOL vscp_information_sendCivilSunriseTwilightTimeEvent(uint8_t userData, uint8_t zone, uint8_t subZone)
{
    vscp_TxMessage txMsg;

    vscp_core_prepareTxMessage(&txMsg, VSCP_CLASS_L1_INFORMATION, VSCP_TYPE_INFORMATION_CIVIL_SUNRISE_TWILIGHT_TIME, VSCP_PRIORITY_3_NORMAL);

    txMsg.dataNum = 3;
    txMsg.data[0] = userData;
    txMsg.data[1] = zone;
    txMsg.data[2] = subZone;

    return vscp_core_sendEvent(&txMsg);
}

/**
 * A node indicates that sunset twilight time is detected/calculated.
 *
 *     Civil twilight is the period when the Sun is below the horizon but its center is less than 6
 * degrees below. The “Civil Twilight Starts” time is the dawn or civil dawn, with the center of the
 * Sun at exactly 6 degrees below the horizon. Equally, the “Civil Twilight Ends” time is dusk or
 * civil dusk, when the Sun is 6 degrees below the horizon in the evening.
 *
 *     During civil twilight, the sky is still illuminated, and with clear weather it is brightest in
 * the direction of the Sun. The Moon and the brightest stars and planets may be visible. It is
 * usually bright enough for outdoor activities without additional lighting.
 *
 *     Near the equator, where the Sun sets and rises in an almost vertical direction, the civil
 * twilight period can last only 21 minutes, a very fast nightfall compared to the much longer periods
 * at southern and northern latitudes. In regions north of 60°24' N or south of 60°24' S, there will
 * be at least one night when it does not get darker than this.
 *
 *     Technically, the start and end times are when the true geocentric position of the Sun is 96
 * degrees from the zenith position.
 *
 * @param[in] userData User specified.
 * @param[in] zone Zone for which event applies to (0-255). 255 is all zones.
 * @param[in] subZone Sub-zone for which event applies to (0-255). 255 is all sub-zones.
 * @return Status
 * @retval FALSE Failed to send the event
 * @retval TRUE  Event successul sent
 *
 */
extern BOOL vscp_information_sendCivilSunsetTwilightTimeEvent(uint8_t userData, uint8_t zone, uint8_t subZone)
{
    vscp_TxMessage txMsg;

    vscp_core_prepareTxMessage(&txMsg, VSCP_CLASS_L1_INFORMATION, VSCP_TYPE_INFORMATION_CIVIL_SUNSET_TWILIGHT_TIME, VSCP_PRIORITY_3_NORMAL);

    txMsg.dataNum = 3;
    txMsg.data[0] = userData;
    txMsg.data[1] = zone;
    txMsg.data[2] = subZone;

    return vscp_core_sendEvent(&txMsg);
}

/**
 * A node indicates that nautical sunrise twilight time is detected/calculated.
 *
 *     Nautical twilight is the period when the center of the Sun is between 6 and 12 degrees below
 * the horizon, when bright stars are still visible in clear weather and the horizon is becoming
 * visible. It is too dark to do outdoor activities without additional lighting.
 *
 *     In the morning, nautical twilight starts at nautical dawn, when the Sun rises above 12 degrees
 * below the horizon; it ends when the Sun's center reaches 6 degrees below the horizon. In the
 * evening, nautical twilight begins when the Sun sinks below 6 degrees; it ends at nautical dusk,
 * when the Sun is lower than 12 degrees below the horizon.
 *
 *     For locations north of 54°34' N or south of 54°34' S latitude, the Sun will never be lower than
 * 12 degrees below the horizon for a period in the summer.
 *
 *     Technically, the start and end times are when the true geocentric position of the Sun is 102
 * degrees from the zenith position.
 *
 * @param[in] userData User specified.
 * @param[in] zone Zone for which event applies to (0-255). 255 is all zones.
 * @param[in] subZone Sub-zone for which event applies to (0-255). 255 is all sub-zones.
 * @return Status
 * @retval FALSE Failed to send the event
 * @retval TRUE  Event successul sent
 *
 */
extern BOOL vscp_information_sendNauticalSunriseTwilightTimeEvent(uint8_t userData, uint8_t zone, uint8_t subZone)
{
    vscp_TxMessage txMsg;

    vscp_core_prepareTxMessage(&txMsg, VSCP_CLASS_L1_INFORMATION, VSCP_TYPE_INFORMATION_NAUTICAL_SUNRISE_TWILIGHT_TIME, VSCP_PRIORITY_3_NORMAL);

    txMsg.dataNum = 3;
    txMsg.data[0] = userData;
    txMsg.data[1] = zone;
    txMsg.data[2] = subZone;

    return vscp_core_sendEvent(&txMsg);
}

/**
 * A node indicates that nautical sunset twilight time is detected/calculated.
 *
 *     Nautical twilight is the period when the center of the Sun is between 6 and 12 degrees below
 * the horizon, when bright stars are still visible in clear weather and the horizon is becoming
 * visible. It is too dark to do outdoor activities without additional lighting.
 *
 *     In the morning, nautical twilight starts at nautical dawn, when the Sun rises above 12 degrees
 * below the horizon; it ends when the Sun's center reaches 6 degrees below the horizon. In the
 * evening, nautical twilight begins when the Sun sinks below 6 degrees; it ends at nautical dusk,
 * when the Sun is lower than 12 degrees below the horizon.
 *
 *     For locations north of 54°34' N or south of 54°34' S latitude, the Sun will never be lower than
 * 12 degrees below the horizon for a period in the summer.
 *
 *     Technically, the start and end times are when the true geocentric position of the Sun is 102
 * degrees from the zenith position.
 *
 * @param[in] userData User specified.
 * @param[in] zone Zone for which event applies to (0-255). 255 is all zones.
 * @param[in] subZone Sub-zone for which event applies to (0-255). 255 is all sub-zones.
 * @return Status
 * @retval FALSE Failed to send the event
 * @retval TRUE  Event successul sent
 *
 */
extern BOOL vscp_information_sendNauticalSunsetTwilightTimeEvent(uint8_t userData, uint8_t zone, uint8_t subZone)
{
    vscp_TxMessage txMsg;

    vscp_core_prepareTxMessage(&txMsg, VSCP_CLASS_L1_INFORMATION, VSCP_TYPE_INFORMATION_NAUTICAL_SUNSET_TWILIGHT_TIME, VSCP_PRIORITY_3_NORMAL);

    txMsg.dataNum = 3;
    txMsg.data[0] = userData;
    txMsg.data[1] = zone;
    txMsg.data[2] = subZone;

    return vscp_core_sendEvent(&txMsg);
}

/**
 * A node indicates that astronomical sunrise twilight time is detected/calculated.
 *
 *     Astronomical twilight is the period when the center of the Sun is between 12 and 18 degrees
 * below the horizon. It starts at astronomical dawn, early in the morning when the Sun is higher than
 * 18 degrees below the horizon. From this point, it will be difficult to observe certain faint stars,
 * galaxies, and other objects because the Sun starts to illuminate the sky. Astronomical twilight
 * ends at astronomical dusk in the late evening, when those faint objects again can be visible
 * because the Sun is lower than 18 degrees below the horizon. In locations north of 48°24' N or south
 * of 48°24', it never gets darker than this near the middle of the summer solstice (June or
 * December).
 *
 *     Technically, the start and end times are when the true geocentric position of the Sun is 108
 * degrees from the zenith position, or directly above the observer.
 *
 *     Astronomical twilight is the period when the center of the Sun is between 12 and 18 degrees
 * below the horizon.
 *
 * @param[in] userData User specified.
 * @param[in] zone Zone for which event applies to (0-255). 255 is all zones.
 * @param[in] subZone Sub-zone for which event applies to (0-255). 255 is all sub-zones.
 * @return Status
 * @retval FALSE Failed to send the event
 * @retval TRUE  Event successul sent
 *
 */
extern BOOL vscp_information_sendAstronomicalSunriseTwilightTimeEvent(uint8_t userData, uint8_t zone, uint8_t subZone)
{
    vscp_TxMessage txMsg;

    vscp_core_prepareTxMessage(&txMsg, VSCP_CLASS_L1_INFORMATION, VSCP_TYPE_INFORMATION_ASTRONOMICAL_SUNRISE_TWILIGHT_TIME, VSCP_PRIORITY_3_NORMAL);

    txMsg.dataNum = 3;
    txMsg.data[0] = userData;
    txMsg.data[1] = zone;
    txMsg.data[2] = subZone;

    return vscp_core_sendEvent(&txMsg);
}

/**
 * A node indicates that astronomical sunset twilight time is detected/calculated.
 *
 *     Astronomical twilight is the period when the center of the Sun is between 12 and 18 degrees
 * below the horizon. It starts at astronomical dawn, early in the morning when the Sun is higher than
 * 18 degrees below the horizon. From this point, it will be difficult to observe certain faint stars,
 * galaxies, and other objects because the Sun starts to illuminate the sky. Astronomical twilight
 * ends at astronomical dusk in the late evening, when those faint objects again can be visible
 * because the Sun is lower than 18 degrees below the horizon. In locations north of 48°24' N or south
 * of 48°24', it never gets darker than this near the middle of the summer solstice (June or
 * December).
 *
 *     Technically, the start and end times are when the true geocentric position of the Sun is 108
 * degrees from the zenith position, or directly above the observer.
 *
 *     Astronomical twilight is the period when the center of the Sun is between 12 and 18 degrees
 * below the horizon.
 *
 * @param[in] userData User specified.
 * @param[in] zone Zone for which event applies to (0-255). 255 is all zones.
 * @param[in] subZone Sub-zone for which event applies to (0-255). 255 is all sub-zones.
 * @return Status
 * @retval FALSE Failed to send the event
 * @retval TRUE  Event successul sent
 *
 */
extern BOOL vscp_information_sendAstronomicalSunsetTwilightTimeEvent(uint8_t userData, uint8_t zone, uint8_t subZone)
{
    vscp_TxMessage txMsg;

    vscp_core_prepareTxMessage(&txMsg, VSCP_CLASS_L1_INFORMATION, VSCP_TYPE_INFORMATION_ASTRONOMICAL_SUNSET_TWILIGHT_TIME, VSCP_PRIORITY_3_NORMAL);

    txMsg.dataNum = 3;
    txMsg.data[0] = userData;
    txMsg.data[1] = zone;
    txMsg.data[2] = subZone;

    return vscp_core_sendEvent(&txMsg);
}

/**
 * This event is used for reporting of a calculated noon (real noon).
 *
 * @param[in] zone Zone for which event applies to (0-255). 255 is all zones.
 * @param[in] subZone Sub-zone for which event applies to (0-255). 255 is all sub-zones.
 * @return Status
 * @retval FALSE Failed to send the event
 * @retval TRUE  Event successul sent
 *
 */
extern BOOL vscp_information_sendCalculatedNoonEvent(uint8_t zone, uint8_t subZone)
{
    vscp_TxMessage txMsg;

    vscp_core_prepareTxMessage(&txMsg, VSCP_CLASS_L1_INFORMATION, VSCP_TYPE_INFORMATION_CALCULATED_NOON, VSCP_PRIORITY_3_NORMAL);

    txMsg.dataNum = 3;
    txMsg.data[0] = 0;
    txMsg.data[1] = zone;
    txMsg.data[2] = subZone;

    return vscp_core_sendEvent(&txMsg);
}

/**
 * Shutter is moving up.
 *
 * @param[in] reserved Reserved
 * @param[in] zone Zone for which event applies to (0-255). 255 is all zones.
 * @param[in] subZone Sub-zone for which event applies to (0-255). 255 is all sub-zones.
 * @return Status
 * @retval FALSE Failed to send the event
 * @retval TRUE  Event successul sent
 *
 */
extern BOOL vscp_information_sendShutterUpEvent(uint8_t reserved, uint8_t zone, uint8_t subZone)
{
    vscp_TxMessage txMsg;

    vscp_core_prepareTxMessage(&txMsg, VSCP_CLASS_L1_INFORMATION, VSCP_TYPE_INFORMATION_SHUTTER_UP, VSCP_PRIORITY_3_NORMAL);

    txMsg.dataNum = 3;
    txMsg.data[0] = reserved;
    txMsg.data[1] = zone;
    txMsg.data[2] = subZone;

    return vscp_core_sendEvent(&txMsg);
}

/**
 * Shutter is moving down.
 *
 * @param[in] reserved Reserved
 * @param[in] zone Zone for which event applies to (0-255). 255 is all zones.
 * @param[in] subZone Sub-zone for which event applies to (0-255). 255 is all sub-zones.
 * @return Status
 * @retval FALSE Failed to send the event
 * @retval TRUE  Event successul sent
 *
 */
extern BOOL vscp_information_sendShutterDownEvent(uint8_t reserved, uint8_t zone, uint8_t subZone)
{
    vscp_TxMessage txMsg;

    vscp_core_prepareTxMessage(&txMsg, VSCP_CLASS_L1_INFORMATION, VSCP_TYPE_INFORMATION_SHUTTER_DOWN, VSCP_PRIORITY_3_NORMAL);

    txMsg.dataNum = 3;
    txMsg.data[0] = reserved;
    txMsg.data[1] = zone;
    txMsg.data[2] = subZone;

    return vscp_core_sendEvent(&txMsg);
}

/**
 * Shutter is moving left.
 *
 * @param[in] reserved Reserved
 * @param[in] zone Zone for which event applies to (0-255). 255 is all zones.
 * @param[in] subZone Sub-zone for which event applies to (0-255). 255 is all sub-zones.
 * @return Status
 * @retval FALSE Failed to send the event
 * @retval TRUE  Event successul sent
 *
 */
extern BOOL vscp_information_sendShutterLeftEvent(uint8_t reserved, uint8_t zone, uint8_t subZone)
{
    vscp_TxMessage txMsg;

    vscp_core_prepareTxMessage(&txMsg, VSCP_CLASS_L1_INFORMATION, VSCP_TYPE_INFORMATION_SHUTTER_LEFT, VSCP_PRIORITY_3_NORMAL);

    txMsg.dataNum = 3;
    txMsg.data[0] = reserved;
    txMsg.data[1] = zone;
    txMsg.data[2] = subZone;

    return vscp_core_sendEvent(&txMsg);
}

/**
 * Shutter is moving right.
 *
 * @param[in] reserved Reserved
 * @param[in] zone Zone for which event applies to (0-255). 255 is all zones.
 * @param[in] subZone Sub-zone for which event applies to (0-255). 255 is all sub-zones.
 * @return Status
 * @retval FALSE Failed to send the event
 * @retval TRUE  Event successul sent
 *
 */
extern BOOL vscp_information_sendShutterRightEvent(uint8_t reserved, uint8_t zone, uint8_t subZone)
{
    vscp_TxMessage txMsg;

    vscp_core_prepareTxMessage(&txMsg, VSCP_CLASS_L1_INFORMATION, VSCP_TYPE_INFORMATION_SHUTTER_RIGHT, VSCP_PRIORITY_3_NORMAL);

    txMsg.dataNum = 3;
    txMsg.data[0] = reserved;
    txMsg.data[1] = zone;
    txMsg.data[2] = subZone;

    return vscp_core_sendEvent(&txMsg);
}

/**
 * Shutter reached top end.
 *
 * @param[in] reserved Reserved
 * @param[in] zone Zone for which event applies to (0-255). 255 is all zones.
 * @param[in] subZone Sub-zone for which event applies to (0-255). 255 is all sub-zones.
 * @return Status
 * @retval FALSE Failed to send the event
 * @retval TRUE  Event successul sent
 *
 */
extern BOOL vscp_information_sendShutterReachedTopEndEvent(uint8_t reserved, uint8_t zone, uint8_t subZone)
{
    vscp_TxMessage txMsg;

    vscp_core_prepareTxMessage(&txMsg, VSCP_CLASS_L1_INFORMATION, VSCP_TYPE_INFORMATION_SHUTTER_REACHED_TOP_END, VSCP_PRIORITY_3_NORMAL);

    txMsg.dataNum = 3;
    txMsg.data[0] = reserved;
    txMsg.data[1] = zone;
    txMsg.data[2] = subZone;

    return vscp_core_sendEvent(&txMsg);
}

/**
 * Shutter reached bottom end.
 *
 * @param[in] reserved Reserved
 * @param[in] zone Zone for which event applies to (0-255). 255 is all zones.
 * @param[in] subZone Sub-zone for which event applies to (0-255). 255 is all sub-zones.
 * @return Status
 * @retval FALSE Failed to send the event
 * @retval TRUE  Event successul sent
 *
 */
extern BOOL vscp_information_sendShutterReachedBottomEndEvent(uint8_t reserved, uint8_t zone, uint8_t subZone)
{
    vscp_TxMessage txMsg;

    vscp_core_prepareTxMessage(&txMsg, VSCP_CLASS_L1_INFORMATION, VSCP_TYPE_INFORMATION_SHUTTER_REACHED_BOTTOM_END, VSCP_PRIORITY_3_NORMAL);

    txMsg.dataNum = 3;
    txMsg.data[0] = reserved;
    txMsg.data[1] = zone;
    txMsg.data[2] = subZone;

    return vscp_core_sendEvent(&txMsg);
}

/**
 * Shutter reached middle end.
 *
 * @param[in] reserved Reserved
 * @param[in] zone Zone for which event applies to (0-255). 255 is all zones.
 * @param[in] subZone Sub-zone for which event applies to (0-255). 255 is all sub-zones.
 * @return Status
 * @retval FALSE Failed to send the event
 * @retval TRUE  Event successul sent
 *
 */
extern BOOL vscp_information_sendShutterReachedMiddleEndEvent(uint8_t reserved, uint8_t zone, uint8_t subZone)
{
    vscp_TxMessage txMsg;

    vscp_core_prepareTxMessage(&txMsg, VSCP_CLASS_L1_INFORMATION, VSCP_TYPE_INFORMATION_SHUTTER_REACHED_MIDDLE_END, VSCP_PRIORITY_3_NORMAL);

    txMsg.dataNum = 3;
    txMsg.data[0] = reserved;
    txMsg.data[1] = zone;
    txMsg.data[2] = subZone;

    return vscp_core_sendEvent(&txMsg);
}

/**
 * Shutter reached preset end.
 *
 * @param[in] reserved Reserved
 * @param[in] zone Zone for which event applies to (0-255). 255 is all zones.
 * @param[in] subZone Sub-zone for which event applies to (0-255). 255 is all sub-zones.
 * @return Status
 * @retval FALSE Failed to send the event
 * @retval TRUE  Event successul sent
 *
 */
extern BOOL vscp_information_sendShutterReachedPresetEndEvent(uint8_t reserved, uint8_t zone, uint8_t subZone)
{
    vscp_TxMessage txMsg;

    vscp_core_prepareTxMessage(&txMsg, VSCP_CLASS_L1_INFORMATION, VSCP_TYPE_INFORMATION_SHUTTER_REACHED_PRESET_END, VSCP_PRIORITY_3_NORMAL);

    txMsg.dataNum = 3;
    txMsg.data[0] = reserved;
    txMsg.data[1] = zone;
    txMsg.data[2] = subZone;

    return vscp_core_sendEvent(&txMsg);
}

/**
 * Shutter reached preset left.
 *
 * @param[in] reserved Reserved
 * @param[in] zone Zone for which event applies to (0-255). 255 is all zones.
 * @param[in] subZone Sub-zone for which event applies to (0-255). 255 is all sub-zones.
 * @return Status
 * @retval FALSE Failed to send the event
 * @retval TRUE  Event successul sent
 *
 */
extern BOOL vscp_information_sendShutterReachedPresetLeftEvent(uint8_t reserved, uint8_t zone, uint8_t subZone)
{
    vscp_TxMessage txMsg;

    vscp_core_prepareTxMessage(&txMsg, VSCP_CLASS_L1_INFORMATION, VSCP_TYPE_INFORMATION_SHUTTER_REACHED_PRESET_LEFT, VSCP_PRIORITY_3_NORMAL);

    txMsg.dataNum = 3;
    txMsg.data[0] = reserved;
    txMsg.data[1] = zone;
    txMsg.data[2] = subZone;

    return vscp_core_sendEvent(&txMsg);
}

/**
 * Shutter reached preset right.
 *
 * @param[in] reserved Reserved
 * @param[in] zone Zone for which event applies to (0-255). 255 is all zones.
 * @param[in] subZone Sub-zone for which event applies to (0-255). 255 is all sub-zones.
 * @return Status
 * @retval FALSE Failed to send the event
 * @retval TRUE  Event successul sent
 *
 */
extern BOOL vscp_information_sendShutterReachedPresetRightEvent(uint8_t reserved, uint8_t zone, uint8_t subZone)
{
    vscp_TxMessage txMsg;

    vscp_core_prepareTxMessage(&txMsg, VSCP_CLASS_L1_INFORMATION, VSCP_TYPE_INFORMATION_SHUTTER_REACHED_PRESET_RIGHT, VSCP_PRIORITY_3_NORMAL);

    txMsg.dataNum = 3;
    txMsg.data[0] = reserved;
    txMsg.data[1] = zone;
    txMsg.data[2] = subZone;

    return vscp_core_sendEvent(&txMsg);
}

/**
 * Long click detected.
 *
 * @param[in] index Index for device generating long click. Set to zero if not used.
 * @param[in] zone Zone for which event applies to (0-255). 255 is all zones.
 * @param[in] subZone Sub-zone for which event applies to (0-255). 255 is all sub-zones.
 * @return Status
 * @retval FALSE Failed to send the event
 * @retval TRUE  Event successul sent
 *
 */
extern BOOL vscp_information_sendLongClickEvent(uint8_t index, uint8_t zone, uint8_t subZone)
{
    vscp_TxMessage txMsg;

    vscp_core_prepareTxMessage(&txMsg, VSCP_CLASS_L1_INFORMATION, VSCP_TYPE_INFORMATION_LONG_CLICK, VSCP_PRIORITY_3_NORMAL);

    txMsg.dataNum = 3;
    txMsg.data[0] = index;
    txMsg.data[1] = zone;
    txMsg.data[2] = subZone;

    return vscp_core_sendEvent(&txMsg);
}

/**
 * Single click detected.
 *
 * @param[in] index Index for device generating single click. Set to zero if not used.
 * @param[in] zone Zone for which event applies to (0-255). 255 is all zones.
 * @param[in] subZone Sub-zone for which event applies to (0-255). 255 is all sub-zones.
 * @return Status
 * @retval FALSE Failed to send the event
 * @retval TRUE  Event successul sent
 *
 */
extern BOOL vscp_information_sendSingleClickEvent(uint8_t index, uint8_t zone, uint8_t subZone)
{
    vscp_TxMessage txMsg;

    vscp_core_prepareTxMessage(&txMsg, VSCP_CLASS_L1_INFORMATION, VSCP_TYPE_INFORMATION_SINGLE_CLICK, VSCP_PRIORITY_3_NORMAL);

    txMsg.dataNum = 3;
    txMsg.data[0] = index;
    txMsg.data[1] = zone;
    txMsg.data[2] = subZone;

    return vscp_core_sendEvent(&txMsg);
}

/**
 * Double click detected.
 *
 * @param[in] index Index for device generating double click. Set to zero if not used.
 * @param[in] zone Zone for which event applies to (0-255). 255 is all zones.
 * @param[in] subZone Sub-zone for which event applies to (0-255). 255 is all sub-zones.
 * @return Status
 * @retval FALSE Failed to send the event
 * @retval TRUE  Event successul sent
 *
 */
extern BOOL vscp_information_sendDoubleClickEvent(uint8_t index, uint8_t zone, uint8_t subZone)
{
    vscp_TxMessage txMsg;

    vscp_core_prepareTxMessage(&txMsg, VSCP_CLASS_L1_INFORMATION, VSCP_TYPE_INFORMATION_DOUBLE_CLICK, VSCP_PRIORITY_3_NORMAL);

    txMsg.dataNum = 3;
    txMsg.data[0] = index;
    txMsg.data[1] = zone;
    txMsg.data[2] = subZone;

    return vscp_core_sendEvent(&txMsg);
}

/**
 * Send date event.
 *
 * @param[in] index Index for device generating date. Set to zero if not used. 
 * @param[in] zone Zone for which event applies to (0-255). 255 is all zones.
 * @param[in] subZone Sub-zone for which event applies to (0-255). 255 is all sub-zones.
 * @param[in] century Year century
 * @param[in] year Year
 * @param[in] month Month (1-12)
 * @param[in] day Day (1-31)
 * @return Status
 * @retval FALSE Failed to send the event
 * @retval TRUE  Event successul sent
 *
 */
extern BOOL vscp_information_sendDateEvent(uint8_t index, uint8_t zone, uint8_t subZone, uint8_t century, uint8_t year, uint8_t month, uint8_t day)
{
    vscp_TxMessage txMsg;

    vscp_core_prepareTxMessage(&txMsg, VSCP_CLASS_L1_INFORMATION, VSCP_TYPE_INFORMATION_DATE, VSCP_PRIORITY_3_NORMAL);

    txMsg.dataNum = 7;
    txMsg.data[0] = index;
    txMsg.data[1] = zone;
    txMsg.data[2] = subZone;
    txMsg.data[3] = century;
    txMsg.data[4] = year;
    txMsg.data[5] = month;
    txMsg.data[6] = day;

    return vscp_core_sendEvent(&txMsg);
}

/**
 * Send time event.
 *
 * @param[in] index Index for device generating time. Set to zero if not used. 
 * @param[in] zone Zone for which event applies to (0-255). 255 is all zones.
 * @param[in] subZone Sub-zone for which event applies to (0-255). 255 is all sub-zones.
 * @param[in] hour Hour (0-23)
 * @param[in] minutes Minutes (0-59)
 * @param[in] seconds Seconds (0-59)
 * @param[in] milliseconds Milliseconds (0-999)
 * @return Status
 * @retval FALSE Failed to send the event
 * @retval TRUE  Event successul sent
 *
 */
extern BOOL vscp_information_sendTimeEvent(uint8_t index, uint8_t zone, uint8_t subZone, uint8_t hour, uint8_t minutes, uint8_t seconds, uint16_t milliseconds)
{
    vscp_TxMessage txMsg;

    vscp_core_prepareTxMessage(&txMsg, VSCP_CLASS_L1_INFORMATION, VSCP_TYPE_INFORMATION_TIME, VSCP_PRIORITY_3_NORMAL);

    txMsg.dataNum = 8;
    txMsg.data[0] = index;
    txMsg.data[1] = zone;
    txMsg.data[2] = subZone;
    txMsg.data[3] = hour;
    txMsg.data[4] = minutes;
    txMsg.data[5] = seconds;
    txMsg.data[6] = (uint8_t)((milliseconds >> 8) & 0xff);
    txMsg.data[7] = (uint8_t)((milliseconds >> 0) & 0xff);

    return vscp_core_sendEvent(&txMsg);
}

/**
 * Send day of the week event.
 *
 * @param[in] index Index for device generating weekday. Set to zero if not used. 
 * @param[in] zone Zone for which event applies to (0-255). 255 is all zones.
 * @param[in] subZone Sub-zone for which event applies to (0-255). 255 is all sub-zones.
 * @param[in] weekday Day of the week (0: Monday, 6: Sunday)
 * @return Status
 * @retval FALSE Failed to send the event
 * @retval TRUE  Event successul sent
 *
 */
extern BOOL vscp_information_sendWeekdayEvent(uint8_t index, uint8_t zone, uint8_t subZone, uint8_t weekday)
{
    vscp_TxMessage txMsg;

    vscp_core_prepareTxMessage(&txMsg, VSCP_CLASS_L1_INFORMATION, VSCP_TYPE_INFORMATION_WEEKDAY, VSCP_PRIORITY_3_NORMAL);

    txMsg.dataNum = 4;
    txMsg.data[0] = index;
    txMsg.data[1] = zone;
    txMsg.data[2] = subZone;
    txMsg.data[3] = weekday;

    return vscp_core_sendEvent(&txMsg);
}

/**
 * A device got locked.
 *
 * @param[in] index Index for device. Set to zero if not used.
 * @param[in] zone Zone for which event applies to (0-255). 255 is all zones.
 * @param[in] subZone Sub-zone for which event applies to (0-255). 255 is all sub-zones.
 * @return Status
 * @retval FALSE Failed to send the event
 * @retval TRUE  Event successul sent
 *
 */
extern BOOL vscp_information_sendLockEvent(uint8_t index, uint8_t zone, uint8_t subZone)
{
    vscp_TxMessage txMsg;

    vscp_core_prepareTxMessage(&txMsg, VSCP_CLASS_L1_INFORMATION, VSCP_TYPE_INFORMATION_LOCK, VSCP_PRIORITY_3_NORMAL);

    txMsg.dataNum = 3;
    txMsg.data[0] = index;
    txMsg.data[1] = zone;
    txMsg.data[2] = subZone;

    return vscp_core_sendEvent(&txMsg);
}

/**
 * A device got unlocked.
 *
 * @param[in] index Index for device. Set to zero if not used.
 * @param[in] zone Zone for which event applies to (0-255). 255 is all zones.
 * @param[in] subZone Sub-zone for which event applies to (0-255). 255 is all sub-zones.
 * @return Status
 * @retval FALSE Failed to send the event
 * @retval TRUE  Event successul sent
 *
 */
extern BOOL vscp_information_sendUnlockEvent(uint8_t index, uint8_t zone, uint8_t subZone)
{
    vscp_TxMessage txMsg;

    vscp_core_prepareTxMessage(&txMsg, VSCP_CLASS_L1_INFORMATION, VSCP_TYPE_INFORMATION_UNLOCK, VSCP_PRIORITY_3_NORMAL);

    txMsg.dataNum = 3;
    txMsg.data[0] = index;
    txMsg.data[1] = zone;
    txMsg.data[2] = subZone;

    return vscp_core_sendEvent(&txMsg);
}

/**
 * A device generated a date/time event. Time is UTC.
 *
 * @param[in] index Index for device. Set to zero if not used.
 * @param[in] zone Zone for which event applies to (0-255). 255 is all zones.
 * @param[in] subZone Sub-zone for which event applies to (0-255). 255 is all sub-zones.
 * @param[in] year Year (0-4095)
 * @param[in] month Month (1-12)
 * @param[in] day Day (1-31)
 * @param[in] hour Hour (0-23)
 * @param[in] minute Minute (0-59)
 * @param[in] second Second (0-59)
 * @return Status
 * @retval FALSE Failed to send the event
 * @retval TRUE  Event successul sent
 *
 */
extern BOOL vscp_information_sendDateTime(uint8_t index, uint8_t zone, uint8_t subZone, uint16_t year, uint8_t month, uint8_t day, uint8_t hour, uint8_t minute, uint8_t second)
{
    vscp_TxMessage txMsg;

    /* Year
     *   mask: 0x0fff
     *   bit position: 26-37
     * 
     * Month
     *    mask: 0x0f
     *    bit position: 22-25
     * 
     * Day
     *     mask: 0x1f
     *     bit position: 17-21
     * 
     * Hour
     *     mask: 0x1f
     *     bit position: 12-16
     * 
     * Minute
     *     mask: 0x3f
     *     bit position: 6-11
     *
     * Second
     *     mask: 0x3f
     *     bit position: 0-5
     */

    vscp_core_prepareTxMessage(&txMsg, VSCP_CLASS_L1_INFORMATION, VSCP_TYPE_INFORMATION_DATETIME, VSCP_PRIORITY_3_NORMAL);

    txMsg.dataNum = 8;
    txMsg.data[0] = index;
    txMsg.data[1] = zone;
    txMsg.data[2] = subZone;
    /* 32-39 */
    txMsg.data[3] = (year & 0x0fc0) >> 7;
    /* 24-31 */
    txMsg.data[4] = ((year & 0x003f) << 2) | ((month & 0x0c) >> 2);
    /* 16-23 */
    txMsg.data[5] = ((month & 0x03) << 6) | ((day & 0x1f) << 1) | ((hour & 0x10) >> 4);
    /* 8-15 */
    txMsg.data[6] = ((hour & 0x0f) << 4) | ((minute & 0x3c) >> 2);
    /* 0-7 */
    txMsg.data[7] = ((minute & 0x03) << 6) | ((second & 0x3f) >> 0);

    return vscp_core_sendEvent(&txMsg);
}

/**
 * A rising (edge) is detected.
 *
 * @param[in] index Index for device. Set to zero if not used.
 * @param[in] zone Zone for which event applies to (0-255). 255 is all zones.
 * @param[in] subZone Sub-zone for which event applies to (0-255). 255 is all sub-zones.
 * @return Status
 * @retval FALSE Failed to send the event
 * @retval TRUE  Event successul sent
 *
 */
extern BOOL vscp_information_sendRisingEvent(uint8_t index, uint8_t zone, uint8_t subZone)
{
    vscp_TxMessage txMsg;

    vscp_core_prepareTxMessage(&txMsg, VSCP_CLASS_L1_INFORMATION, VSCP_TYPE_INFORMATION_RISING, VSCP_PRIORITY_3_NORMAL);

    txMsg.dataNum = 3;
    txMsg.data[0] = index;
    txMsg.data[1] = zone;
    txMsg.data[2] = subZone;

    return vscp_core_sendEvent(&txMsg);
}

/**
 * A falling (edge) is detected.
 *
 * @param[in] index Index for device. Set to zero if not used.
 * @param[in] zone Zone for which event applies to (0-255). 255 is all zones.
 * @param[in] subZone Sub-zone for which event applies to (0-255). 255 is all sub-zones.
 * @return Status
 * @retval FALSE Failed to send the event
 * @retval TRUE  Event successul sent
 *
 */
extern BOOL vscp_information_sendFallingEvent(uint8_t index, uint8_t zone, uint8_t subZone)
{
    vscp_TxMessage txMsg;

    vscp_core_prepareTxMessage(&txMsg, VSCP_CLASS_L1_INFORMATION, VSCP_TYPE_INFORMATION_FALLING, VSCP_PRIORITY_3_NORMAL);

    txMsg.dataNum = 3;
    txMsg.data[0] = index;
    txMsg.data[1] = zone;
    txMsg.data[2] = subZone;

    return vscp_core_sendEvent(&txMsg);
}

/*******************************************************************************
    LOCAL FUNCTIONS
*******************************************************************************/

